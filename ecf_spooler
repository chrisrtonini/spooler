# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301,  USA

#!/bin/bash
#
# chkconfig: 345 80 80
#
# description: Script para iniciar gateway de ECF.
#
# Autor: Chris Robert Tonini <chrisrtonini@gmail.com>
#

### BEGIN INIT INFO
# Provides: ecf_spooler
# Required-Start: $ALL $local
# Required-Stop:
# Default-Start: 3 5
# Default-Stop:
# Description: Script para iniciar gateway de ECF.
### END INIT INFO


# Definicoes...
# -------------
SPOOLER_BIN=/usr/local/bin/spooler


# Echo para indicar finalizacao
# forcada de operacao (start/stop)
# --------------------------------
echo_passed()	{
	echo "Passou!"
}


# Echo para indicar falha na
# operacao (start/stop)
# --------------------------
echo_fail()	{
	echo "Falhou!"
}


# Echo para indicar sucesso na
# operacao (start/stop)
# ----------------------------
echo_success()	{
	echo "Ok!"
}


# Obtem o PID da aplicacao, cujo nome do
# executavel eh passado como argumento.
# $1 : Nome do aplicativo.
# ---------------------------------------
get_pid()	{
	local pid=""
	
	pid=$(ps aux | grep -m1 "$1" | grep -v grep | awk -F" " '{print $2}')
	echo "$pid"
}


# Verifica se um determinado PID existe
# Retorno : "found" ou "not found"
# -------------------------------------
check_pid()	{
	[ -e /proc/$1 ] && echo "found"
	[ ! -e /proc/$1 ] && echo "not found"
}


# Termina a execucao de um processo.
# Obs.: Envia SIGTERM ao processo e caso este
#       nao seja terminado, envia SIGKILL.
# -------------------------------------------
terminate_pid()	{
	if [ -n "$1" ];
	then
		echo -en "\tFinalizando $1 com SIGTERM: "
		kill -TERM $1
		
		sleep 0.2s
		if [ "$(check_pid $1)" == "found" ];
		then
			echo -e "\n\tProcesso nao foi finalizado."
			echo -en "\tFinalizando $1 com SIGKILL: ";
			kill -9 $1;
		fi
		
		if [ "$(check_pid $1)" == "not found" ];
		then
			echo_success
		else
			echo_fail
		fi
	fi
}


# Executa o aplicativo em backbround
# ----------------------------------
exec_daemon()	{
	${SPOOLER_BIN} 2>&1>/dev/null
	if [ $? == 0 ];
	then
		echo_success
	else
		echo_fail
	fi
}


# Atende ao argumento "start" da
# linha de comando.
# ------------------------------
start()	{
	echo "Iniciando spooler (${SPOOLER_BIN})"
	exec_daemon $SPOOLER_BIN
}


# Atende ao argumento "stop"
# da lina de comando.
# --------------------------
stop()	{
	local pid=""
	
	echo "Parando spooler (${SPOOLER_BIN})"
	pid=$(get_pid "spooler")
	terminate_pid $pid
}


# Atende ao argumento "status" da linha
# de comando, reportando o PID, caso o
# processo esteja rodando.
# -------------------------------------
status()	{
	local pid=""
	
	echo "Verificando spooler (${SPOOLER_BIN})"
	pid=$(get_pid "spooler")
	
	if [ -n "$pid" ] ;
	then
		echo -e "${SPOOLER_BIN} rodando com PID $pid"
	else
		echo -e "${SPOOLER_BIN} nao esta rodando"
	fi
}


# Avaliacao do argumento de linha de comando
# conforme o padrao SYSV.
# ------------------------------------------
case "$1" in
	start)
		start
		;;
	stop)
		stop
		;;
	status)
		status
		;;
	*)
		echo "Use $0 {start|stop|status}"
		;;
esac
